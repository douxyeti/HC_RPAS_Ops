import os
from dotenv import load_dotenv
from kivymd.app import MDApp
from kivymd.uix.screenmanager import MDScreenManager
from kivy.uix.screenmanager import SlideTransition
from kivy.lang import Builder
from kivy.clock import Clock
import traceback
from kivy.clock import Clock

# Flag module-level (anti double déclenchement)
_DEV_LAUNCH_DID_RUN = False

def _dev_invoke_and_launch_once(*_args):
    """Crée l’invocation Firestore vers 'test_module' (route='dashboard')
    puis lance le module. Protégé contre les doubles déclenchements."""
    global _DEV_LAUNCH_DID_RUN
    if _DEV_LAUNCH_DID_RUN:
        print("[DEV] _dev_invoke_and_launch_once: already ran, skipping")
        return
    _DEV_LAUNCH_DID_RUN = True
    print("[DEV] _dev_invoke_and_launch_once: start")
    try:
        from app.services.firebase_service import FirebaseService
        from app.core.invocation import create_invocation
        from app.core.launcher import launch_module

        fs = FirebaseService.get_instance()
        user_id = getattr(fs, "current_user_id", None) or "unknown_user"

        try:
            create_invocation(
                firebase=fs,
                user_id=user_id,
                module="test_module",
                route="dashboard",
                params={"from": "root"},
                ttl_sec=300,
            )
            print(f"[DEV] invocation written -> invocations_{user_id}/{user_id}_test_module")
        except Exception as e:
            print("[DEV][WARN] create_invocation failed:", e)
            traceback.print_exc()

        print("[DEV] launching module 'test_module' via launcher()")
        p = launch_module("test_module")
        print(f"[DEV] launcher returned: {p!r}")
    except Exception as e:
        print("[DEV][ERROR] _dev_invoke_and_launch_once crashed:", e)
        traceback.print_exc()

# Import des services
from app.services import ConfigService, FirebaseService, RolesManagerService
from app.services.mqtt_service import MQTTService
from app.services.encryption_service import EncryptionService

# Import de l'initialisation des modules
from app.utils.module_initializer import get_module_initializer

# Import des écrans
from app.views.screens.splash_screen import SplashScreen
from app.views.screens.login_screen import LoginScreen
from app.views.screens.dashboard_screen import DashboardScreen
from app.views.screens.specialized_dashboard_screen import SpecializedDashboardScreen
from app.views.screens.roles_manager_screen import RolesManagerScreen
from app.views.screens.role_edit_screen import RoleEditScreen
from app.views.screens.task_manager_screen import TaskManagerScreen
from app.views.screens.procedures_manager_screen import ProceduresManagerScreen
from app.views.screens.modules_admin_screen import ModulesAdminScreen
from app.views.screens.sso_management_screen import SsoManagementScreen

# Import du modèle
from app.models.application_model import ApplicationModel

# Import du container
from app.core.container import Container
from app.core.invocation import create_invocation
from app.core.launcher import launch_module
from app.services.firebase_service import FirebaseService
from app.core.invocation_mixin import InvocationConsumerMixin

class MainScreenManager(InvocationConsumerMixin, MDScreenManager):
    MODULE_NAME = "RPAS_PRINCIPAL"
    ROUTE_ON_INVOCATION = "dashboard"

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.transition = SlideTransition()
        # Ajouter les écrans dans l'ordre
        self.add_widget(SplashScreen(name="splash"))
        self.add_widget(LoginScreen(name="login"))
        self.add_widget(DashboardScreen(name="dashboard"))
        self.add_widget(SpecializedDashboardScreen(name="specialized_dashboard"))
        self.add_widget(RolesManagerScreen(name="roles_manager"))
        self.add_widget(RoleEditScreen(name="role_edit"))
        self.add_widget(TaskManagerScreen(name="task_manager"))
        self.add_widget(ModulesAdminScreen(name="modules_admin"))
        self.add_widget(SsoManagementScreen(name="sso_management"))

    def on_start(self):
        # ... (logique existante on_start ici)
        firebase_service = FirebaseService.get_instance()
        current_user_id = getattr(firebase_service, "current_user_id", None) or "unknown_user"
        self.consume_invocation_for_self(firebase_service, current_user_id)
        print("[DEV] on_start hook -> scheduling _dev_invoke_and_launch_once in 1.0s")
        Clock.schedule_once(_dev_invoke_and_launch_once, 1.0)
        print("[DEV] on_start hook -> scheduling _dev_invoke_and_launch_once in 1.0s")
        Clock.schedule_once(_dev_invoke_and_launch_once, 1.0)

        print("[DEV] forcing _dev_invoke_test_strict in 1.0s (no env var needed)")
        Clock.schedule_once(self._dev_invoke_test_strict, 1.0)

class HighCloudRPASApp(MDApp):
    def _dev_invoke_test_strict(self, *args):
        """
        TEST TEMPORAIRE : crée une invocation Firestore vers 'test_module' (route='dashboard')
        puis lance toujours le module. À supprimer après validation.
        """
        try:
            from app.services.firebase_service import FirebaseService
            from app.core.invocation import create_invocation
            from app.core.launcher import launch_module

            fs = FirebaseService.get_instance()
            user_id = getattr(fs, "current_user_id", None) or "unknown_user"

            # 1) Créer l’invocation single-use
            create_invocation(
                firebase=fs,
                user_id=user_id,
                module="test_module",
                route="dashboard",
                params={"from": "root"},
                ttl_sec=300,
            )
            print(f"[DEV] invocation written -> invocations_{user_id}/{user_id}_test_module")

            # 2) Lancer le module quoi qu’il arrive
            print("[DEV] launching module 'test_module'")
            launch_module("test_module")

        except Exception as e:
            print("[DEV][ERROR] _dev_invoke_test_strict:", e)
            traceback.print_exc()

    def _dev_invoke_test_strict(self, *args):
        """
        Envoie une invocation Firestore vers 'test_module' (route='dashboard') et lance TOUJOURS le module.
        Logue tous les détails pour debug.
        """
        print("[DEV] _dev_invoke_test_strict: start")
        try:
            from app.services.firebase_service import FirebaseService
            from app.core.invocation import create_invocation
            from app.core.launcher import launch_module

            fs = FirebaseService.get_instance()
            user_id = getattr(fs, "current_user_id", None) or "unknown_user"
            doc_id = f"{user_id}_test_module"
            coll = f"invocations_{user_id}"
            print(f"[DEV] user_id={user_id} -> will write {coll}/{doc_id}")

            try:
                create_invocation(
                    firebase=fs,
                    user_id=user_id,
                    module="test_module",
                    route="dashboard",
                    params={"from": "root"},
                    ttl_sec=120,
                )
                print(f"[DEV] create_invocation OK -> {coll}/{doc_id}")
            except Exception as e:
                print("[DEV][WARN] create_invocation failed:", e)
                traceback.print_exc()

            print("[DEV] launching module 'test_module' via launcher()")
            p = launch_module("test_module")
            print(f"[DEV] launcher returned: {p!r}")
        except Exception as e:
            print("[DEV][ERROR] _dev_invoke_test_strict crashed:", e)
            traceback.print_exc()

    def _dev_invoke_test(self, *args):
        """Déclenche un envoi d'invocation vers test_module avec logs détaillés, puis lance le module quoi qu'il arrive."""
        try:
            print("[DEV] sending invocation to 'test_module' -> route='dashboard'")
            # IMPORTANT: la méthode send_invocation est sur le ScreenManager (root)
            try:
                App.get_running_app().root.send_invocation("test_module", "dashboard", {"from": "root"}, ttl_sec=120)
                print("[DEV] root.send_invocation() called")
            except Exception as e:
                print("[DEV][WARN] root.send_invocation failed:", e)
                traceback.print_exc()
        finally:
            # Toujours tenter le lancement direct du module pour visualiser la fenêtre
            from app.core.launcher import launch_module
            print("[DEV] ensuring module launch via launcher()")
            launch_module("test_module")

    def _dev_invoke_test(self):
        """Déclenche un envoi d'invocation vers test_module avec logs détaillés et lance toujours le module."""
        try:
            print("[DEV] preparing invocation for 'test_module' -> route='dashboard'")
            # Appel existant : si Firebase n’est pas prêt, on log l’erreur sans bloquer le lancement
            try:
                self.send_invocation("test_module", "dashboard", {"from": "root"}, ttl_sec=120)
                print("[DEV] send_invocation() called")
            except Exception as e:
                print("[DEV][WARN] send_invocation failed:", e)
                traceback.print_exc()
                # Fallback : tenter un lancement direct du module même sans Firestore
                from app.core.launcher import launch_module
                print("[DEV] fallback: launching module directly")
                launch_module("test_module")
        except Exception as e:
            print("[DEV][ERROR] _dev_invoke_test crashed:", e)
            traceback.print_exc()

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.screen_manager = None
        self.config_service = None
        self.firebase_service = None
        self.mqtt_service = None
        self.encryption_service = None
        self.roles_manager_service = None
        self.current_role = None
        self.available_roles = []  # Sera chargé depuis Firebase
        self.is_primary_instance = False  # Indicateur pour la session SSO
        self.model = ApplicationModel()
        
        # Initialiser le container
        self.container = Container()
        self.container.config.from_dict({
            'firebase': {
                'config_path': os.path.join(os.path.dirname(__file__), 'app', 'config', 'firebase_config.json')
            }
        })
        

    def send_invocation(self, target_module: str, route: str = "", params: dict = None, ttl_sec: int = 120):
        """
        Envoie une invocation (si Firebase dispo) puis lance le module.
        """
        from app.services.firebase_service import FirebaseService
        from app.core.invocation import create_invocation
        from app.core.launcher import launch_module

        firebase_service = FirebaseService.get_instance()
        current_user_id = getattr(firebase_service, "current_user_id", None) or "unknown_user"

        try:
            create_invocation(
                firebase=firebase_service,
                user_id=current_user_id,
                module=target_module,
                route=route,
                params=params or {},
                ttl_sec=ttl_sec,
            )
            print(f"[DEV] invocation created for user={current_user_id} module={target_module}")
        except Exception as e:
            print("[DEV][WARN] create_invocation failed:", e)
            traceback.print_exc()
        finally:
            print(f"[DEV] launching module '{target_module}'")
            launch_module(target_module)

        """
        Envoie une invocation vers un autre module et le lance immédiatement.
        """
        firebase_service = FirebaseService.get_instance()
        current_user_id = getattr(firebase_service, "current_user_id", None) or "unknown_user"

        create_invocation(
            firebase=firebase_service,
            user_id=current_user_id,
            module=target_module,
            route=route,
            params=params or {},
            ttl_sec=ttl_sec
        )

        # Lancer le module cible
        launch_module(target_module)
    def build(self):
        # ... logique build existante ...

        # Charge les variables d'environnement
        load_dotenv()
        
        # Définir le thème clair par défaut
        self.theme_cls.theme_style = "Light"
        self.theme_cls.primary_palette = "Blue"  # Couleur principale
        self.theme_cls.accent_palette = "Amber"  # Couleur d'accent
        
        # Récupérer le logger depuis le container
        self.logger = self.container.logger()
        
        try:
            # Initialiser les services (y compris l'initialisation du module)
            self.init_services()
            self.logger.info("Services initialisés avec succès")
        except Exception as e:
            self.logger.error(f"Erreur lors de l'initialisation des services: {str(e)}", exc_info=True)
            raise
        
        # Charge les fichiers KV
        self._load_kv_files()
        
        # Crée le gestionnaire d'écrans
        self.screen_manager = MainScreenManager()
        
        # Ajoute l'écran de gestion des procédures avec son service
        procedures_manager_screen = ProceduresManagerScreen(
            name="procedures_manager",
            procedures_manager_service=self.container.procedures_manager()
        )
        self.screen_manager.add_widget(procedures_manager_screen)
        
        # Définit l'écran initial sur le splash screen
        self.screen_manager.current = "splash"
        
        # Tente une connexion SSO après un court instant, pour laisser le splash screen s'afficher
        Clock.schedule_once(lambda dt: self._check_for_sso_session(), 1)

        return self.screen_manager
        
    def _load_kv_files(self):
        """Charge tous les fichiers KV dynamiquement"""
        from pathlib import Path
        
        # Répertoire contenant les fichiers KV
        kv_directory = Path("app/views/kv")
        
        # Vérifier que le répertoire existe
        if not kv_directory.exists():
            self.logger.error(f"Le répertoire {kv_directory} n'existe pas")
            return
        
        # Liste des fichiers qui doivent être chargés en premier (ordre spécifique si nécessaire)
        # Par exemple, si certains fichiers définissent des widgets utilisés par d'autres
        priority_files = [
            "splash_screen.kv"  # Exemple : charger d'abord l'écran de démarrage
        ]
        
        # Charger d'abord les fichiers prioritaires
        for filename in priority_files:
            kv_file = kv_directory / filename
            if kv_file.exists():
                self.logger.debug(f"Chargement prioritaire du fichier KV: {kv_file}")
                Builder.load_file(str(kv_file))
        
        # Charger tous les autres fichiers .kv
        for kv_file in kv_directory.glob("*.kv"):
            # Ne pas recharger les fichiers prioritaires déjà chargés
            if kv_file.name not in priority_files:
                self.logger.debug(f"Chargement du fichier KV: {kv_file}")
                Builder.load_file(str(kv_file))

    def toggle_theme(self):
        """Bascule entre le thème clair et sombre"""
        self.theme_cls.theme_style = "Dark" if self.theme_cls.theme_style == "Light" else "Light"
        self.logger.info(f"Theme changed to: {self.theme_cls.theme_style}")

    def switch_screen(self, screen_name, direction='left'):
        """Change l'écran courant avec une transition"""
        if screen_name in self.screen_manager.screen_names:
            self.screen_manager.transition.direction = direction
            self.screen_manager.current = screen_name

    def set_role(self, role):
        """Définit le rôle actuel de l'utilisateur"""
        if role in self.available_roles:
            self.current_role = role
            # Met à jour le tableau de bord avec les informations du rôle
            dashboard_screen = self.screen_manager.get_screen('dashboard')
            if dashboard_screen:
                dashboard_screen.title.text = f"Tableau de bord - {role}"

    def load_configuration(self):
        # Code pour charger la configuration
        pass

    def _check_for_sso_session(self):
        """Vérifie la présence d'un token SSO sur MQTT au démarrage, sans forcer de redirection."""
        if not self.mqtt_service or self.mqtt_service.connection_state != 'connected':
            self.logger.warning("SSO Check: MQTT non connecté. La vérification SSO est annulée. L'utilisateur devra se connecter manuellement.")
            return

        sso_config = self.config_service.get_config('sso')
        if not sso_config or not sso_config.get('token_topic'):
            self.logger.warning("SSO Check: Configuration SSO invalide ou absente. La vérification SSO est annulée.")
            return
        
        token_topic = sso_config.get('token_topic')

        # Définit un timeout qui ne fait que logger l'information, sans changer d'écran.
        self._login_timeout = Clock.schedule_once(self._sso_timeout, 2)

        # S'abonne au topic et définit le callback
        try:
            self.mqtt_service.client.subscribe(token_topic)
            self.mqtt_service.register_callback(token_topic, self._on_sso_token_received)
            self.logger.info(f"SSO Check: Abonné au topic '{token_topic}' avec un timeout de 2s.")
        except Exception as e:
            self.logger.error(f"SSO Check: Erreur lors de l'abonnement au topic MQTT: {e}", exc_info=True)

    def _sso_timeout(self, dt):
        """Gère l'expiration du délai de recherche du token SSO."""
        self.logger.info("SSO Check: Timeout. Aucun token SSO reçu. En attente d'une action de l'utilisateur sur l'écran d'accueil.")

    def _on_sso_token_received(self, dt, topic, message):
        """Callback appelé lorsqu'un token SSO est reçu sur MQTT."""
        # Si cette instance est celle qui a initié la connexion, elle ne doit pas traiter son propre token.
        if self.is_primary_instance:
            self.logger.info("SSO Check: Le token a été ignoré car cette instance est la source de la connexion.")
            return

        self.logger.info(f"SSO Check: Token reçu sur le topic '{topic}'. Tentative de connexion.")
        
        # Annuler le timer de timeout car on a reçu un token
        if hasattr(self, '_login_timeout') and self._login_timeout:
            self._login_timeout.cancel()

        try:
            encrypted_token = message
            if not encrypted_token:
                self.logger.warning("SSO Login: Message reçu mais payload vide. Passage à l'écran de connexion.")
                self.switch_screen("login")
                return

            self.logger.info("SSO Login: Token reçu, tentative de déchiffrement et connexion.")
            custom_token = self.encryption_service.decrypt(encrypted_token)
            user_tokens = self.firebase_service.sign_in_with_custom_token(custom_token)
            
            if user_tokens:
                self.logger.info("SSO Login: Connexion automatique réussie.")
                self.load_user_roles()  # Les détails de l'utilisateur sont maintenant dans firebase_service.current_user
                self.switch_screen("dashboard")
            else:
                self.logger.error("SSO Login: Échec de la connexion avec le token personnalisé.")
                self.switch_screen("login")
        except Exception as e:
            self.logger.error(f"SSO Login: Échec du processus de connexion SSO : {e}", exc_info=True)
            self.switch_screen("login")

    def load_user_roles(self):
        """Charge les rôles de l'utilisateur depuis Firebase en utilisant l'utilisateur actuellement connecté."""
        if not self.firebase_service.current_user:
            logging.warning("Load Roles: Attempting to load roles without a logged-in user.")
            return

        try:
            user_id = self.firebase_service.current_user['localId']
            logging.info(f"Load Roles: Loading roles for user {user_id}.")

            # New logic: Fetch the pilot document using the user_id
            pilot_doc = self.firebase_service.get_document('pilots', user_id)

            if not pilot_doc:
                logging.warning(f"Load Roles: No pilot document found for user ID '{user_id}'.")
                self.user_roles = []
                return

            role_name = pilot_doc.get('role_name')
            if not role_name:
                logging.warning(f"Load Roles: 'role_name' not found in pilot document for user '{user_id}'.")
                self.user_roles = []
                return

            logging.info(f"User '{user_id}' has role '{role_name}'. Assigning to user_roles.")
            # For now, we just assign the role name. The dropdown menu will be populated with this.
            self.user_roles = [role_name]
            logging.info(f"Roles loaded for {user_id}: {self.user_roles}")

        except KeyError:
            logging.error("Load Roles: 'localId' not found in self.firebase_service.current_user.")
            self.user_roles = []
        except Exception as e:
            logging.error(f"Load Roles: An unexpected error occurred: {e}")
            self.user_roles = []

    def init_services(self):
        """Initialise tous les services dans le bon ordre."""
        try:
            # 1. Service de configuration
            self.config_service = ConfigService()
            self.logger.info("Service de configuration initialisé")

            # 2. Service MQTT (optionnel)
            if self.config_service.get_config('mqtt.enabled', False):
                self.logger.info("Initialisation du service MQTT...")
                self.mqtt_service = MQTTService()
                broker = self.config_service.get_config('mqtt.broker', 'localhost')
                port = int(self.config_service.get_config('mqtt.port', 1883))
                self.mqtt_service.connect(broker, port)
                self.logger.info(f"Service MQTT connecté à {broker}:{port}")
            else:
                self.logger.info("Service MQTT désactivé dans la configuration")

            # 3. Service Firebase
            self.logger.info("Initialisation du service Firebase...")
            self.firebase_service = FirebaseService.get_instance()
            self.logger.info("Service Firebase initialisé")

            # 4. Vider le cache et lancer l'indexation des modules
            self.logger.info("Préparation de l'indexation des modules...")
            try:
                # Vider le cache pour forcer la relecture depuis Firebase
                self.logger.debug("Nettoyage du cache des modules...")
                self.firebase_service.clear_cache(prefix="module_indexes")
                
                # Lancer l'indexation
                self.logger.info("Lancement de l'indexation...")
                module_initializer = get_module_initializer()
                # --- Appel robuste de ModuleInitializer (API variable selon branches)
                init_methods = [
                    "initialize_with_services",
                    "initialize",
                    "run_indexation",
                    "build_index",
                    "build",
                    "run",
                ]
                called = False
                try:
                    for m in init_methods:
                        if hasattr(module_initializer, m):
                            self.logger.info(f"ModuleInitializer: appel {m}()")
                            getattr(module_initializer, m)(self.firebase_service)
                            called = True
                            break
                    if not called:
                        self.logger.warning("ModuleInitializer: aucune méthode connue trouvée; on continue sans indexation.")
                except Exception:
                    self.logger.exception("Échec de l'initialisation des modules (indexation), on continue quand même.")
                # ---
                self.logger.info("Indexation des modules terminée.")
            except Exception as e:
                self.logger.error(f"Erreur critique lors de l'indexation des modules: {e}", exc_info=True)
            
            # 5. Service de gestion des rôles
            self.logger.info("Initialisation du service de gestion des rôles...")
            self.roles_manager_service = RolesManagerService()
            
            # 6. Chargement des rôles
            self.logger.info("Chargement des rôles depuis Firebase...")
            roles_data = self.roles_manager_service.get_all_roles()
            self.available_roles = [role.get('name') for role in roles_data if role.get('name')]
            self.available_roles.sort()
            self.logger.info(f"{len(self.available_roles)} rôles chargés")

            # Initialise le service de chiffrement
            self.logger.info("Initialisation du service de chiffrement...")
            self.encryption_service = EncryptionService()
            self.logger.info("Service de chiffrement initialisé")
        except Exception as e:
            self.logger.error(f"Échec de l'initialisation d'un service critique: {e}", exc_info=True)
            raise

    def on_stop(self):
        """Méthode exécutée à la fermeture de l'application."""
        self.logger.info("Fermeture de l'application.")
        try:
            if self.mqtt_service and self.mqtt_service.connection_state == 'connected':
                # Seule l'instance primaire qui a initié la session SSO nettoie le token.
                if self.is_primary_instance:
                    self.logger.info("Instance primaire détectée. Nettoyage de la session SSO.")
                    sso_config = self.config_service.get_config('sso')
                    token_topic = sso_config.get('token_topic')
                    if token_topic:
                        self.logger.info(f"Nettoyage du token SSO sur le topic '{token_topic}'.")
                        self.mqtt_service.publish(topic=token_topic, message="", retain=True)
                
                # Toutes les instances se déconnectent proprement du service MQTT.
                self.mqtt_service.disconnect()
                self.logger.info("Service MQTT déconnecté proprement.")
        except Exception as e:
            self.logger.error(f"Erreur lors du nettoyage à la fermeture : {e}", exc_info=True)


if __name__ == "__main__":
    HighCloudRPASApp().run()




